// Code partly generated by ChatGPT and Copilot

#include "Board.h"
#include "Cell.h"
#include <random>
#include <queue>
#include <algorithm>
#include <cassert>
namespace minesweeper {
// --- Constructor -------------------------------------------------------
Board::Board(int width, int height, int mines, std::uint64_t seed) noexcept 
    : width_(width), height_(height), mine_count_(mines), generated_(false),
      lost_(false), hidden_safe_(width * height - mines),
      cells_(width * height), seed_(seed) {}

// --- Getters const ---------------------------------------------------
int Board::width() const noexcept {
    return width_;
}

int Board::height() const noexcept {
    return height_;
}

int Board::mineCount() const noexcept {
    return mine_count_;
}

bool Board::isGenerated() const noexcept {
    return generated_;
}

bool Board::isWon() const noexcept {
    return !lost_ && (hidden_safe_ == 0);
}

bool Board::isLost() const noexcept {
    return lost_;
}

int Board::flagsLeft() const noexcept {
    int flagged_count = 0;
    for (const auto& cell : cells_) {
        if (cell.isFlagged()) {
            ++flagged_count;
        }
    }
    return mine_count_ - flagged_count;
}

const Cell& Board::at(Coord c) const noexcept {
    assert(inBounds(c));
    return cells_[c.row * width_ + c.col];
}

bool Board::inBounds(Coord c) const noexcept {
    return (c.row >= 0 && c.row < height_ && c.col >= 0 && c.col < width_);
}

std::vector<Coord> Board::neighbors(Coord c) const {
    std::vector<Coord> result;
    for (int dr = -1; dr <= 1; ++dr) {
        for (int dc = -1; dc <= 1; ++dc) {
            if (dr == 0 && dc == 0) continue;
            Coord nc{c.row + dr, c.col + dc};
            if (inBounds(nc)) {
                result.push_back(nc);
            }
        }
    }
    return result;
}

// ------------------------Gameplay-----------------------
bool Board::toggleFlag(Coord c) noexcept {
    if (!inBounds(c)) return false;
    Cell& cell = cells_[c.row * width_ + c.col];
    return cell.toggleFlag();
}

RevealResult Board::reveal(Coord c) {
    RevealResult result{ RevealOutcome::Noop, {} };

    // 1) Verification of coordinates
    if (!inBounds(c)) return result;

    Cell& cell = cells_[c.row * width_ + c.col];

    // 2) Nothing if already revealed or flagged
    if (cell.isRevealed() || cell.isFlagged())
        return result;

    // 3) Before first reveal, generate the board
    if (!generated_) {
        generate(c); 
        generated_ = true;
    }

    // 4) if mine -> lost
    if (cell.isMine()) {
        cell.reveal();
        lost_ = true;
        result.outcome = RevealOutcome::Exploded;
        result.revealed.push_back(c);
        return result;
    }

    // 5) Reveal cell and propagate if needed
    if (cell.adjacentMines() == 0) {
        propagateReveal(c, result);
    } else {
        if (cell.reveal()) {
            result.revealed.push_back(c);
            hidden_safe_--;
        }
    }

    // 6) Check win condition
    if (hidden_safe_ == 0) {
        result.outcome = RevealOutcome::Won;
    } 
    else if (!result.revealed.empty()) {
        result.outcome = RevealOutcome::Revealed;
    }

    return result;
}

void Board::propagateReveal(Coord start, RevealResult& result) {
    std::queue<Coord> to_visit;
    to_visit.push(start);

    while (!to_visit.empty()) {
        Coord current = to_visit.front();
        to_visit.pop();

        Cell& cell = cells_[current.row * width_ + current.col];
        if (cell.isRevealed() || cell.isFlagged()) {
            continue; // already revealed or flagged
        }

        if (cell.reveal()) {
            result.revealed.push_back(current);
            hidden_safe_--;
        }

        // If no adjacent mines, enqueue neighbors
        if (cell.adjacentMines() == 0) {
            for (const Coord& n : neighbors(current)) {
                Cell& neighbor_cell = cells_[n.row * width_ + n.col];
                if (neighbor_cell.isHidden() && !neighbor_cell.isMine()) {
                    to_visit.push(n);
                }
            }
        }
    }
}

// ------------------------Random generation of the board---------------------


void Board::generate(Coord safeStart) {
    placeMines(safeStart);
    computeAdjacency();
}

void Board::computeAdjacency() {
    for (int r = 0; r < height_; ++r) {
        for (int c = 0; c < width_; ++c) {
            Coord current{r, c};
            Cell& cell = cells_[r * width_ + c];
            if (cell.isMine()) {
                cell.setAdjacentMines(0);
                continue;
            }
            int mine_count = 0;
            for (const Coord& n : neighbors(current)) {
                if (at(n).isMine()) {
                    mine_count++;
                }
            }
            cell.setAdjacentMines(static_cast<std::uint8_t>(mine_count));
        }
    }
}

namespace {

// splitmix64 hash function
static inline std::uint64_t splitmix64(std::uint64_t x) {
    x += 0x9e3779b97f4a7c15ULL;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9ULL;
    x = (x ^ (x >> 27)) * 0x94d049bb133111ebULL;
    return x ^ (x >> 31);
}

static inline std::uint64_t mix_seed(std::uint64_t base, int row, int col) {
    std::uint64_t h = splitmix64(base);
    h ^= splitmix64(static_cast<std::uint64_t>((static_cast<std::uint64_t>(row) << 32) ^ (std::uint32_t)col));
    return splitmix64(h);
}

} // namespace

// If true, exclude neighbors of first click from mine placement
static constexpr bool kExcludeNeighborsOnFirstClick = true;

void Board::placeMines(Coord safeStart) {
    // 1) Initialze RNG with mixed seed
    std::uint64_t seed_effective = mix_seed(seed_, safeStart.row, safeStart.col);
    std::mt19937_64 rng(seed_effective);

    const auto toIndex = [this](int r, int c) { return r * width_ + c; };

    // 2)  Collect candidate indices (excluding safeStart and possibly neighbors)
    std::vector<int> candidates;
    candidates.reserve(width_ * height_);

    auto isExcluded = [&](int r, int c) {
        if (r == safeStart.row && c == safeStart.col) return true;
        if (kExcludeNeighborsOnFirstClick) {
            // Exclude neighbors
            for (int dr = -1; dr <= 1; ++dr)
                for (int dc = -1; dc <= 1; ++dc) {
                    if (dr == 0 && dc == 0) continue;
                    int rr = safeStart.row + dr;
                    int cc = safeStart.col + dc;
                    if (rr == r && cc == c) return true;
                }
        }
        return false;
    };

    for (int r = 0; r < height_; ++r) {
        for (int c = 0; c < width_; ++c) {
            if (!isExcluded(r, c)) {
                candidates.push_back(toIndex(r, c));
            }
        }
    }

    // 3) Sanity checks
    assert(mine_count_ > 0);
    assert(static_cast<size_t>(mine_count_) <= candidates.size() && "Trop de mines pour le nombre de cases candidates");

    // 4) Shuffle candidates
    std::shuffle(candidates.begin(), candidates.end(), rng);

    // 5) Place mines in the first mine_count_ candidates
    for (int i = 0; i < mine_count_; ++i) {
        int idx = candidates[i];
        cells_[idx].setMine(true);
    }
}


}