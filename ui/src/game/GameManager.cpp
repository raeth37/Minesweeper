// Code generated by ChatGPT (GameManager)

#include "GameManager.h"
#include "Board.h"
#include "Cell.h"

#include <cassert>

namespace minesweeper {

std::uint64_t GameManager::defaultSeed() noexcept {
    // Very simple default seed – in a real project you would probably
    // want to plug in std::random_device or allow the UI layer to
    // provide a seed. Here we just pick a fixed non-zero value to keep
    // behaviour deterministic for testing.
    return 0xDEADBEEFCAFEBABEull;
}

GameManager::GameManager(int width, int height, int mineCount,
                         std::uint64_t seed) noexcept
    : width_(width),
      height_(height),
      mineCount_(mineCount),
      seed_(seed == 0 ? defaultSeed() : seed),
      board_(nullptr),
      state_(State::NotStarted),
      firstClickDone_(false),
      timer_(nullptr)
{
    // We do not create the Board here – startNewGame() will do that.
}

// ---------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------

void GameManager::configure(int width, int height, int mineCount,
                            std::uint64_t seed) noexcept
{
    width_     = width;
    height_    = height;
    mineCount_ = mineCount;
    seed_      = (seed == 0 ? defaultSeed() : seed);

    // After changing configuration the current game, if any, is no
    // longer valid. We mark it as not-started; the UI can call
    // startNewGame() when appropriate.
    board_.reset();
    state_          = State::NotStarted;
    firstClickDone_ = false;
}

// ---------------------------------------------------------------------
// Game lifecycle
// ---------------------------------------------------------------------

void GameManager::startNewGame()
{
    assert(width_ > 0 && height_ > 0 && mineCount_ > 0);

    // Recreate board with the latest configuration.
    board_ = std::make_unique<Board>(width_, height_, mineCount_, seed_);

    state_          = State::Playing;
    firstClickDone_ = false;

    // The timer behaviour is intentionally *not* hard-wired here,
    // because different UIs may prefer to start the timer on the first
    // click instead. The typical pattern would be:
    //
    //   if (timer_) timer_->reset();
    //
    // but we leave that decision to whoever implements TimerManager.
}

// ---------------------------------------------------------------------
// State queries
// ---------------------------------------------------------------------

bool GameManager::checkWin() const noexcept
{
    if (!board_ || state_ == State::Lost || state_ == State::NotStarted) {
        return false;
    }

    // A robust way to detect a win:
    // all non-mine cells must be revealed.
    for (int r = 0; r < board_->height(); ++r) {
        for (int c = 0; c < board_->width(); ++c) {
            Coord coord{r, c};
            const Cell& cell = board_->at(coord);
            if (!cell.isMine() && !cell.isRevealed()) {
                return false;
            }
        }
    }
    return true;
}

// ---------------------------------------------------------------------
// Input handling
// ---------------------------------------------------------------------

void GameManager::onLeftClick(int row, int col)
{
    if (!board_) {
        // No game yet – start one now using the stored configuration.
        startNewGame();
    }

    if (state_ != State::Playing || !board_) {
        return;
    }

    // Bounds check – Board will also guard against invalid coords, but
    // this keeps us safe even if its implementation changes.
    if (row < 0 || col < 0 || row >= height_ || col >= width_) {
        return;
    }

    Coord coord{row, col};
    Cell& cell = const_cast<Cell&>(board_->at(coord));

    if (cell.isFlagged() || cell.isRevealed()) {
        // Flags / already-revealed cells are ignored on left-click.
        return;
    }

    if (!firstClickDone_) {
        firstClickDone_ = true;
        // Typical timing behaviour: start timer on first user action.
        // We do NOT hard-code timer_->start() here, but the comment
        // shows where that call would naturally live.
        //
        // if (timer_) timer_->start();
    }

    // Ask the board to perform the reveal + propagation.
    // We intentionally ignore the RevealResult value – the GameManager
    // derives win/lose purely from board state so that its logic
    // remains decoupled from Board's internal data structures.
    (void) board_->reveal(coord);

    // Check for loss: revealing a mine.
    if (cell.isMine()) {
        state_ = State::Lost;
        // Stopping the timer (if any) would logically go here.
        // if (timer_) timer_->stop();
        return;
    }

    // Check for win after the reveal propagation.
    if (checkWin()) {
        state_ = State::Won;
        // if (timer_) timer_->stop();
    }
}

void GameManager::onRightClick(int row, int col)
{
    if (state_ != State::Playing || !board_) {
        return;
    }

    if (row < 0 || col < 0 || row >= height_ || col >= width_) {
        return;
    }

    Coord coord{row, col};

    const Cell& cell = board_->at(coord);

    if (cell.isRevealed()) {
        // Usually right-clicking a revealed cell does nothing in
        // classic Minesweeper; if your group wants "chording" behaviour
        // this is the place to implement it.
        return;
    }

    // Simple toggle flag behaviour – use Board's helper so that flag
    // accounting (flagsLeft(), etc.) stays consistent.
    board_->toggleFlag(coord);
}

// ---------------------------------------------------------------------
// Internal helpers (currently very light)
// ---------------------------------------------------------------------

void GameManager::applyRevealOutcome(const Coord&,
                                     RevealOutcome)
{
    // At the moment we don't make decisions based on RevealOutcome
    // because we recompute win/lose from the board itself. This method
    // is kept as an extension point in case your group decides to use
    // Board's higher-level reveal API.
}

void GameManager::updateWinStateAfterReveal()
{
    if (state_ == State::Playing && checkWin()) {
        state_ = State::Won;
    }
}

} // namespace minesweeper
